### Eclipse Workspace Patch 1.0
#P rhino
Index: src/org/mozilla/javascript/InterpreterData.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/InterpreterData.java,v
retrieving revision 1.55
diff -u -r1.55 InterpreterData.java
--- src/org/mozilla/javascript/InterpreterData.java	4 Apr 2007 20:52:10 -0000	1.55
+++ src/org/mozilla/javascript/InterpreterData.java	28 Aug 2008 23:10:07 -0000
@@ -107,6 +107,9 @@
     String encodedSource;
     int encodedSourceStart;
     int encodedSourceEnd;
+    
+    // Marcello: Added JSDoc
+    String jsDoc;
 
     int languageVersion;
 
@@ -164,6 +167,11 @@
         return itsSourceFile;
     }
 
+    public String getJSDoc()
+    {
+        return jsDoc;
+    }
+
     public boolean isGeneratedScript()
     {
         return ScriptRuntime.isGeneratedScript(itsSourceFile);
Index: src/org/mozilla/javascript/BaseFunction.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/BaseFunction.java,v
retrieving revision 1.67
diff -u -r1.67 BaseFunction.java
--- src/org/mozilla/javascript/BaseFunction.java	22 Jul 2008 18:49:41 -0000	1.67
+++ src/org/mozilla/javascript/BaseFunction.java	28 Aug 2008 23:10:03 -0000
@@ -273,6 +273,8 @@
                 } else {
                     indent = 0;
                 }
+                if (args.length>=2)
+                    flags |= ScriptRuntime.toInt32(args[1]);
             }
             return realf.decompile(indent, flags);
           }
Index: src/org/mozilla/javascript/Decompiler.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Decompiler.java,v
retrieving revision 1.25
diff -u -r1.25 Decompiler.java
--- src/org/mozilla/javascript/Decompiler.java	11 Jul 2007 16:00:00 -0000	1.25
+++ src/org/mozilla/javascript/Decompiler.java	28 Aug 2008 23:10:04 -0000
@@ -86,6 +86,17 @@
      * Flag to indicate that the decompilation generates toSource result.
      */
     public static final int TO_SOURCE_FLAG = 1 << 1;
+    
+    /**
+     * Flag to indicate that the decompilation generates a compressed result.
+     */
+    public static final int COMPRESS_FLAG = 1 << 2;
+
+    /**
+     * Flag to indicate that the decompilation generates a compressed result.
+     */
+    public static final int COMPRESS_NEWLINES_FLAG = 1 << 3;
+    
 
     /**
      * Decompilation property to specify initial ident value.
@@ -302,6 +313,10 @@
         StringBuffer result = new StringBuffer();
         boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));
         boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));
+        // Compress: features
+        boolean compress = (0 != (flags & Decompiler.COMPRESS_FLAG));
+        boolean compressnl = (0 != (flags & Decompiler.COMPRESS_NEWLINES_FLAG));
+        TokenMapper tm = new TokenMapper();
 
         // Spew tokens in source, for debugging.
         // as TYPE number char
@@ -333,6 +348,10 @@
         int braceNesting = 0;
         boolean afterFirstEOL = false;
         int i = 0;
+		int prevToken = 0;
+		boolean primeFunctionNesting = false;
+		boolean inArgsList = false;
+		boolean primeInArgsList = false;
         int topFunctionType;
         if (source.charAt(i) == Token.SCRIPT) {
             ++i;
@@ -343,7 +362,9 @@
 
         if (!toSource) {
             // add an initial newline to exactly match js.
-            result.append('\n');
+            // Compress: features
+            if (!compress)
+            	result.append('\n');
             for (int j = 0; j < indent; j++)
                 result.append(' ');
         } else {
@@ -365,7 +386,14 @@
 
             case Token.NAME:
             case Token.REGEXP:  // re-wrapped in '/'s in parser...
-                i = printSourceString(source, i + 1, false, result);
+            	// Compress:
+				int jumpPos = getSourceStringEnd(source, i+1);
+				if (!compress || Token.OBJECTLIT == source.charAt(jumpPos)) {
+					i = printSourceString(source, i + 1, false, result);
+				} else {
+					i = tm.printCompressed(	source, i + 1, false, result, prevToken, 
+											inArgsList, braceNesting);
+				}
                 continue;
 
             case Token.STRING:
@@ -394,7 +422,11 @@
 
             case Token.FUNCTION:
                 ++i; // skip function type
-                result.append("function ");
+				primeInArgsList = true;
+				primeFunctionNesting = true;
+                result.append("function");
+                if (Token.LP != getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case FUNCTION_END:
@@ -402,7 +434,7 @@
                 break;
 
             case Token.COMMA:
-                result.append(", ");
+                result.append(compress ? "," : ", ");
                 break;
 
             case Token.LC:
@@ -413,6 +445,7 @@
                 break;
 
             case Token.RC: {
+				tm.leaveNestingLevel(braceNesting);
                 --braceNesting;
                 /* don't print the closing RC if it closes the
                  * toplevel function and we're called from
@@ -430,18 +463,29 @@
                     case Token.WHILE:
                     case Token.ELSE:
                         indent -= indentGap;
-                        result.append(' ');
+                        if (!compress)
+	                        result.append(' ');
                         break;
                 }
                 break;
             }
             case Token.LP:
+				if (primeInArgsList) {
+					inArgsList = true;
+					primeInArgsList = false;
+				}
+				if (primeFunctionNesting) {
+					tm.enterNestingLevel(braceNesting);
+					primeFunctionNesting = false;
+				}
                 result.append('(');
                 break;
 
             case Token.RP:
+				if (inArgsList)
+					inArgsList = false;
                 result.append(')');
-                if (Token.LC == getNext(source, length, i))
+                if (!compress && Token.LC == getNext(source, length, i))
                     result.append(' ');
                 break;
 
@@ -467,7 +511,7 @@
                         newLine = false;
                     }
                 }
-                if (newLine) {
+                if (newLine && !compressnl) {
                     result.append('\n');
                 }
 
@@ -495,8 +539,9 @@
                             less = indentGap;
                     }
 
-                    for (; less < indent; less++)
-                        result.append(' ');
+					if (!compress)
+					    for (; less < indent; less++)
+					        result.append(' ');
                 }
                 break;
             }
@@ -513,15 +558,17 @@
                 break;
 
             case Token.IF:
-                result.append("if ");
+                result.append(compress ? "if" : "if ");
                 break;
 
             case Token.ELSE:
-                result.append("else ");
+                result.append(compress ? "else" : "else ");
                 break;
 
             case Token.FOR:
-                result.append("for ");
+                result.append("for");
+                if (!compress || Token.NAME == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.IN:
@@ -529,27 +576,27 @@
                 break;
 
             case Token.WITH:
-                result.append("with ");
+                result.append(compress ? "with" : "with ");
                 break;
 
             case Token.WHILE:
-                result.append("while ");
+                result.append(compress ? "while" : "while ");
                 break;
 
             case Token.DO:
-                result.append("do ");
+                result.append(compress ? "do" : "do ");
                 break;
 
             case Token.TRY:
-                result.append("try ");
+                result.append(compress ? "try" : "try ");
                 break;
 
             case Token.CATCH:
-                result.append("catch ");
+                result.append(compress ? "catch" : "catch ");
                 break;
 
             case Token.FINALLY:
-                result.append("finally ");
+                result.append(compress ? "finally" : "finally ");
                 break;
 
             case Token.THROW:
@@ -557,7 +604,7 @@
                 break;
 
             case Token.SWITCH:
-                result.append("switch ");
+                result.append(compress ? "switch" : "switch ");
                 break;
 
             case Token.BREAK:
@@ -574,6 +621,8 @@
 
             case Token.CASE:
                 result.append("case ");
+                if (!compress || Token.NAME == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.DEFAULT:
@@ -603,55 +652,55 @@
                 break;
 
             case Token.ASSIGN:
-                result.append(" = ");
+                result.append(compress ? "=" : " = ");
                 break;
 
             case Token.ASSIGN_ADD:
-                result.append(" += ");
+                result.append(compress ? "+=" : " += ");
                 break;
 
             case Token.ASSIGN_SUB:
-                result.append(" -= ");
+                result.append(compress ? "-=" : " -= ");
                 break;
 
             case Token.ASSIGN_MUL:
-                result.append(" *= ");
+                result.append(compress ? "*=" : " *= ");
                 break;
 
             case Token.ASSIGN_DIV:
-                result.append(" /= ");
+                result.append(compress ? "/=" : " /= ");
                 break;
 
             case Token.ASSIGN_MOD:
-                result.append(" %= ");
+                result.append(compress ? "%=" : " %= ");
                 break;
 
             case Token.ASSIGN_BITOR:
-                result.append(" |= ");
+                result.append(compress ? "|=" : " |= ");
                 break;
 
             case Token.ASSIGN_BITXOR:
-                result.append(" ^= ");
+                result.append(compress ? "^=" : " ^= ");
                 break;
 
             case Token.ASSIGN_BITAND:
-                result.append(" &= ");
+                result.append(compress ? "&=" : " &= ");
                 break;
 
             case Token.ASSIGN_LSH:
-                result.append(" <<= ");
+                result.append(compress ? "<<=" : " <<= ");
                 break;
 
             case Token.ASSIGN_RSH:
-                result.append(" >>= ");
+                result.append(compress ? ">>=" : " >>= ");
                 break;
 
             case Token.ASSIGN_URSH:
-                result.append(" >>>= ");
+                result.append(compress ? ">>>=" : " >>>= ");
                 break;
 
             case Token.HOOK:
-                result.append(" ? ");
+                result.append(compress ? "?" : " ? ");
                 break;
 
             case Token.OBJECTLIT:
@@ -669,59 +718,59 @@
                     result.append(':');
                 else
                     // it's the middle part of a ternary
-                    result.append(" : ");
+                    result.append(compress ? ":" : " : ");
                 break;
 
             case Token.OR:
-                result.append(" || ");
+                result.append(compress ? "||" : " || ");
                 break;
 
             case Token.AND:
-                result.append(" && ");
+                result.append(compress ? "&&" : " && ");
                 break;
 
             case Token.BITOR:
-                result.append(" | ");
+                result.append(compress ? "|" : " | ");
                 break;
 
             case Token.BITXOR:
-                result.append(" ^ ");
+                result.append(compress ? "^" : " ^ ");
                 break;
 
             case Token.BITAND:
-                result.append(" & ");
+                result.append(compress ? "&" : " & ");
                 break;
 
             case Token.SHEQ:
-                result.append(" === ");
+                result.append(compress ? "===" : " === ");
                 break;
 
             case Token.SHNE:
-                result.append(" !== ");
+                result.append(compress ? "!==" : " !== ");
                 break;
 
             case Token.EQ:
-                result.append(" == ");
+                result.append(compress ? "==" : " == ");
                 break;
 
             case Token.NE:
-                result.append(" != ");
+                result.append(compress ? "!=" : " != ");
                 break;
 
             case Token.LE:
-                result.append(" <= ");
+                result.append(compress ? "<=" : " <= ");
                 break;
 
             case Token.LT:
-                result.append(" < ");
+                result.append(compress ? "<" : " < ");
                 break;
 
             case Token.GE:
-                result.append(" >= ");
+                result.append(compress ? ">=" : " >= ");
                 break;
 
             case Token.GT:
-                result.append(" > ");
+                result.append(compress ? ">" : " > ");
                 break;
 
             case Token.INSTANCEOF:
@@ -729,15 +778,15 @@
                 break;
 
             case Token.LSH:
-                result.append(" << ");
+                result.append(compress ? "<<" : " << ");
                 break;
 
             case Token.RSH:
-                result.append(" >> ");
+                result.append(compress ? ">>" : " >> ");
                 break;
 
             case Token.URSH:
-                result.append(" >>> ");
+                result.append(compress ? ">>>" : " >>> ");
                 break;
 
             case Token.TYPEOF:
@@ -773,31 +822,39 @@
                 break;
 
             case Token.INC:
+				if (compress && Token.ADD == prevToken)
+					result.append(' ');
                 result.append("++");
+                if (compress && Token.ADD == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.DEC:
+				if (compress && Token.SUB == prevToken)
+					result.append(' ');
                 result.append("--");
+                if (compress && Token.SUB == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.ADD:
-                result.append(" + ");
+                result.append(compress ? "+" : " + ");
                 break;
 
             case Token.SUB:
-                result.append(" - ");
+                result.append(compress ? "-" : " - ");
                 break;
 
             case Token.MUL:
-                result.append(" * ");
+                result.append(compress ? "*" : " * ");
                 break;
 
             case Token.DIV:
-                result.append(" / ");
+                result.append(compress ? "/" : " / ");
                 break;
 
             case Token.MOD:
-                result.append(" % ");
+                result.append(compress ? "%" : " % ");
                 break;
 
             case Token.COLONCOLON:
@@ -826,7 +883,7 @@
 
         if (!toSource) {
             // add that trailing newline if it's an outermost function.
-            if (!justFunctionBody)
+            if (!justFunctionBody && !compressnl)
                 result.append('\n');
         } else {
             if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {
@@ -916,3 +973,111 @@
     private static final boolean printSource = false;
 
 }
+
+
+class TokenMapper {
+	private java.util.ArrayList functionBracePositions = 
+        new java.util.ArrayList();
+	private java.util.ArrayList scopeReplacedTokens = new java.util.ArrayList();
+	private int tokenCount = 10;
+
+	// FIXME: this isn't the brightest way to accomplish this. Firstly, we need
+	// to be sure we aren't colliding with other things in the namespace!
+	private String getMappedToken(String token, boolean newMapping) {
+		String nt = null;
+        java.util.HashMap tokens = (java.util.HashMap)scopeReplacedTokens.get(scopeReplacedTokens.size()-1);
+		if (newMapping) {
+			nt = new String(Integer.toString(tokenCount++,26));
+			tokens.put(token, nt);
+			return nt;
+		}
+        String mapping = getTokenMapping(token);
+        if (mapping==null)
+            return token;
+        return mapping;
+	}
+
+	private boolean hasLocalTokenMapping(String token) {
+		if (scopeReplacedTokens.size() < 1)
+			return false;
+        java.util.HashMap tokens = (java.util.HashMap)(scopeReplacedTokens.get(scopeReplacedTokens.size()-1));
+		if (tokens.containsKey(token))
+			return true;
+		return false;
+	}
+
+	private String getTokenMapping(String token) {
+		for (int i=scopeReplacedTokens.size()-1; i>=0; i--) {
+            java.util.HashMap tokens = (java.util.HashMap)(scopeReplacedTokens.get(i));
+			if (tokens.containsKey(token))
+				return (String)tokens.get(token);
+		}
+		return null;
+	}
+
+	public int printCompressed(String 		source, 
+								int 		offset,
+								boolean 	asQuotedString,
+								StringBuffer sb, 
+								int 		prevToken, 
+								boolean 	inArgsList, 
+								int 		currentLevel) {
+		boolean newMapping = false;
+		int length = source.charAt(offset);
+		++offset;
+		if ((0x8000 & length) != 0) {
+			length = ((0x7FFF & length) << 16) | source.charAt(offset);
+			++offset;
+		}
+
+		if (sb != null) {
+			String str = source.substring(offset, offset + length);
+			String sourceStr = new String(str);
+			if (((prevToken == Token.VAR)&&(!hasLocalTokenMapping(sourceStr)))||(inArgsList))
+				newMapping = true;
+
+
+			if (((functionBracePositions.size()>0)&&(currentLevel>=(((Integer)functionBracePositions.get(functionBracePositions.size()-1)).intValue())))||(inArgsList))
+				if(prevToken != Token.DOT)
+					str = this.getMappedToken(str, newMapping);
+			if ((!inArgsList)&&(asQuotedString))
+				if((prevToken == Token.LC)||(prevToken == Token.COMMA))
+					str = sourceStr;
+
+			if(!asQuotedString){
+				sb.append(str);
+			} else {
+				sb.append('"');
+				sb.append(ScriptRuntime.escapeString(str));
+				sb.append('"');
+			}
+		}
+
+		return offset + length;
+	}
+
+	public void enterNestingLevel(int braceNesting){
+		functionBracePositions.add(new Integer(braceNesting+1));
+		scopeReplacedTokens.add(new java.util.HashMap());
+	}
+
+	public void leaveNestingLevel(int braceNesting){
+		Integer bn = new Integer(braceNesting);
+		if ((functionBracePositions.contains(bn))&&(scopeReplacedTokens.size()>0)) {
+			// remove our mappings now!
+			int scopedSize = scopeReplacedTokens.size();
+			/*
+			HashMap tokens = (HashMap)(scopeReplacedTokens.get(scopedSize-1));
+			Iterator titer = (tokens.keySet()).iterator();
+			String key = null;
+			while(titer.hasNext()){
+				key = (String)titer.next();
+				// System.out.println("removing: "+key);
+				tokenMappings.remove(key);
+			}
+			*/
+			scopeReplacedTokens.remove(scopedSize-1);
+			functionBracePositions.remove(bn);
+		}
+	}
+}
Index: src/org/mozilla/javascript/Interpreter.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java,v
retrieving revision 1.349
diff -u -r1.349 Interpreter.java
--- src/org/mozilla/javascript/Interpreter.java	25 Aug 2008 16:42:32 -0000	1.349
+++ src/org/mozilla/javascript/Interpreter.java	28 Aug 2008 23:10:07 -0000
@@ -542,6 +542,7 @@
         itsData.itsFunctionType = theFunction.getFunctionType();
         itsData.itsNeedsActivation = theFunction.requiresActivation();
         itsData.itsName = theFunction.getFunctionName();
+        itsData.jsDoc = theFunction.getJSDoc();
         if (!theFunction.getIgnoreDynamicScope()) {
             if (compilerEnv.isUseDynamicScope()) {
                 itsData.useDynamicScope = true;
Index: src/org/mozilla/javascript/FunctionNode.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/FunctionNode.java,v
retrieving revision 1.33
diff -u -r1.33 FunctionNode.java
--- src/org/mozilla/javascript/FunctionNode.java	18 Mar 2008 15:10:16 -0000	1.33
+++ src/org/mozilla/javascript/FunctionNode.java	28 Aug 2008 23:10:04 -0000
@@ -107,6 +107,14 @@
         return itsFunctionType;
     }
 
+    public void setJSDoc(String s) {
+        this.jsDoc = s;
+    }
+    public String getJSDoc() {
+        return jsDoc;
+    }
+ 
+    String jsDoc = null;
     String functionName;
     int itsFunctionType;
     boolean itsNeedsActivation;
Index: src/org/mozilla/javascript/TokenStream.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java,v
retrieving revision 1.71
diff -u -r1.71 TokenStream.java
--- src/org/mozilla/javascript/TokenStream.java	19 Jun 2008 17:30:46 -0000	1.71
+++ src/org/mozilla/javascript/TokenStream.java	28 Aug 2008 23:10:09 -0000
@@ -294,6 +294,8 @@
     final int getLineno() { return lineno; }
 
     final String getString() { return string; }
+    
+    final String getJSDoc() { String s = jsDoc; jsDoc = null; return s; }
 
     final double getNumber() { return number; }
 
@@ -759,6 +761,11 @@
                 }
                 if (matchChar('*')) {
                     boolean lookForSlash = false;
+                    // Marcello: JSDoc patch
+                    boolean potentialJSDoc = true;
+                    boolean inJSDoc = false;
+                    boolean readJSDoc = false;
+                    int jsDocStep = 1; // 0: space, 1: star, 2: space, 3: text
                     for (;;) {
                         c = getChar();
                         if (c == EOF_CHAR) {
@@ -766,13 +773,47 @@
                             return Token.ERROR;
                         } else if (c == '*') {
                             lookForSlash = true;
+                            if (potentialJSDoc) {
+                                inJSDoc = true;
+                                potentialJSDoc = false;
+                                stringBufferTop = 0;
+                                continue;
+                            }
                         } else if (c == '/') {
                             if (lookForSlash) {
+                                if (inJSDoc)
+                                    this.jsDoc = getStringFromBuffer();
                                 continue retry;
                             }
                         } else {
                             lookForSlash = false;
                         }
+                        potentialJSDoc = false;
+                        if (inJSDoc) {
+                            // If we hit a newline restart step
+                            if (c=='\n' && jsDocStep>=1) {
+                                jsDocStep = 0;
+                                if (readJSDoc)
+                                    addToString(c);
+                                continue;
+                            } else if (jsDocStep<3) {
+                                // Ignore asterisks if we're in step 0/1
+                                if (c=='*') {
+                                    if (jsDocStep==0)
+                                        jsDocStep=1;
+                                    if (jsDocStep==1) 
+                                        continue;
+                                // Ignore spaces in steps 0,1,2
+                                } else if (isJSSpace(c)) {
+                                    if (jsDocStep==1)
+                                        jsDocStep = 2;
+                                    continue;
+                                }   
+                            }
+                            jsDocStep = 3;
+                            addToString(c);
+                            readJSDoc = true;
+                        }
                     }
                 }
 
@@ -1432,6 +1473,9 @@
     // code.
     private String string = "";
     private double number;
+    
+    // Marcello: store jsdoc
+    private String jsDoc = null;
 
     private char[] stringBuffer = new char[128];
     private int stringBufferTop;
Index: src/org/mozilla/javascript/InterpretedFunction.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/InterpretedFunction.java,v
retrieving revision 1.59
diff -u -r1.59 InterpretedFunction.java
--- src/org/mozilla/javascript/InterpretedFunction.java	26 Jun 2008 13:57:11 -0000	1.59
+++ src/org/mozilla/javascript/InterpretedFunction.java	28 Aug 2008 23:10:04 -0000
@@ -137,6 +137,17 @@
         if (idata.itsRegExpLiterals != null) {
             functionRegExps = createRegExpWraps(cx, scope);
         }
+        if (idata.jsDoc != null) {
+            defineProperty("__jsdoc__", 
+            		Context.toString(idata.getJSDoc()), 
+            		ScriptableObject.DONTENUM);
+            defineProperty("__source__", 
+            		Context.toString(idata.getSourceName()),
+            		ScriptableObject.DONTENUM);
+            defineProperty("__lines__", 
+            		Context.javaToJS(idata.getLineNumbers(), scope),
+            		ScriptableObject.DONTENUM);
+        }
     }
 
     @Override
Index: src/org/mozilla/javascript/Parser.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java,v
retrieving revision 1.128
diff -u -r1.128 Parser.java
--- src/org/mozilla/javascript/Parser.java	16 May 2008 21:13:01 -0000	1.128
+++ src/org/mozilla/javascript/Parser.java	28 Aug 2008 23:10:08 -0000
@@ -479,6 +479,9 @@
     {
         int syntheticType = functionType;
         int baseLineno = ts.getLineno();  // line number where source starts
+        
+        // Marcello: JSDoc addition
+        String jsDoc = ts.getJSDoc();
 
         int functionSourceStart = decompiler.markFunctionStart(functionType);
         String name;
@@ -633,6 +636,9 @@
         fnNode.setSourceName(sourceURI);
         fnNode.setBaseLineno(baseLineno);
         fnNode.setEndLineno(ts.getLineno());
+        // Marcello: JSDoc addition
+        fnNode.setJSDoc(jsDoc);
+         
 
         Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
         if (memberExprNode != null) {
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java,v
retrieving revision 1.14
diff -u -r1.14 XmlProcessor.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java	2 Jul 2008 18:16:35 -0000	1.14
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java	28 Aug 2008 23:10:10 -0000
@@ -246,14 +246,17 @@
         }
     }
 
+	// XML+Reader patch by Marcello Bastea-Forte (marcello@cellosoft.com)
     final Node toXml(String defaultNamespaceUri, String xml) throws org.xml.sax.SAXException {
+ 		String syntheticXml = "<parent xmlns=\"" + defaultNamespaceUri + "\">" + xml + "</parent>";
+		return toXml(defaultNamespaceUri,new java.io.StringReader(syntheticXml));
+	}
+	final Node toXml(String defaultNamespaceUri, java.io.Reader reader) throws org.xml.sax.SAXException {
         //    See ECMA357 10.3.1
         DocumentBuilder builder = null;
         try {
-            String syntheticXml = "<parent xmlns=\"" + defaultNamespaceUri +
-                "\">" + xml + "</parent>";
             builder = getDocumentBuilderFromPool(); 
-            Document document = builder.parse( new org.xml.sax.InputSource(new java.io.StringReader(syntheticXml)) );
+            Document document = builder.parse( new org.xml.sax.InputSource(reader) );
             if (ignoreProcessingInstructions) {
                 List<Node> list = new java.util.ArrayList<Node>();
                 addProcessingInstructionsTo(list, document);
@@ -282,7 +285,8 @@
             }
             NodeList rv = document.getDocumentElement().getChildNodes();
             if (rv.getLength() > 1) {
-                throw ScriptRuntime.constructError("SyntaxError", "XML objects may contain at most one node.");
+				return document.getDocumentElement();
+				//throw ScriptRuntime.constructError("SyntaxError", "XML objects may contain at most one node.");
             } else if (rv.getLength() == 0) {
                 Node node = document.createTextNode("");
                 return node;
@@ -292,7 +296,7 @@
                 return node;
             }
         } catch (java.io.IOException e) {
-            throw new RuntimeException("Unreachable.");
+            throw new RuntimeException(e);
         } catch (javax.xml.parsers.ParserConfigurationException e) {
             throw new RuntimeException(e);
         } finally {
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java,v
retrieving revision 1.26
diff -u -r1.26 XMLLibImpl.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java	25 Mar 2008 13:38:52 -0000	1.26
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java	28 Aug 2008 23:10:09 -0000
@@ -405,6 +405,13 @@
             throw ScriptRuntime.typeError("Cannot parse XML: " + e.getMessage());
         }
     }
+	private XML parse(java.io.Reader reader) {
+		try {
+			return newXML(XmlNode.createElement(options, getDefaultNamespaceURI(Context.getCurrentContext()), reader));
+		} catch (org.xml.sax.SAXException e) {
+			throw ScriptRuntime.typeError("Cannot parse XML: " + e.getMessage());
+		}		
+	}
 
     final XML ecmaToXml(Object object) {
         //    See ECMA357 10.3
@@ -418,6 +425,11 @@
                 throw ScriptRuntime.typeError("Cannot convert list of >1 element to XML");
             }
         }
+		if (object instanceof NativeJavaObject) {
+			Object javaObject = ((NativeJavaObject)object).unwrap();
+			if (javaObject instanceof java.io.Reader)
+				return parse((java.io.Reader)javaObject);
+		}
         //    TODO    Technically we should fail on anything except a String, Number or Boolean
         //            See ECMA357 10.3
         // Extension: if object is a DOM node, use that to construct the XML
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java,v
retrieving revision 1.11
diff -u -r1.11 XmlNode.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java	22 Aug 2008 16:09:45 -0000	1.11
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java	28 Aug 2008 23:10:10 -0000
@@ -118,7 +118,10 @@
     static XmlNode createElement(XmlProcessor processor, String namespaceUri, String xml) throws org.xml.sax.SAXException {
         return createImpl( processor.toXml(namespaceUri, xml) );
     }
-
+    static XmlNode createElement(XmlProcessor processor, String namespaceUri, java.io.Reader xml) throws org.xml.sax.SAXException {
+		return createImpl( processor.toXml(namespaceUri, xml) );
+	}
+    
     static XmlNode createEmpty(XmlProcessor processor) {
         return createText(processor, "");
     }
Index: .classpath
===================================================================
RCS file: .classpath
diff -N .classpath
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ .classpath	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="xmlimplsrc"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

### Eclipse Workspace Patch 1.0
#P rhinocvs
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java,v
retrieving revision 1.20
diff -u -r1.20 XMLLibImpl.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java	6 Feb 2007 17:48:45 -0000	1.20
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XMLLibImpl.java	6 Aug 2007 16:09:27 -0000
@@ -411,6 +411,14 @@
 			throw ScriptRuntime.typeError("Cannot parse XML: " + e.getMessage());
 		}		
 	}
+	private XML parse(java.io.Reader reader) {
+		try {
+			return newXML(XmlNode.createElement(options, getDefaultNamespaceURI(Context.getCurrentContext()), reader));
+		} catch (org.xml.sax.SAXException e) {
+			throw ScriptRuntime.typeError("Cannot parse XML: " + e.getMessage());
+		}		
+	}
+	
 	
 	final XML ecmaToXml(Object object) {
 		//	See ECMA357 10.3
@@ -424,6 +432,11 @@
 				throw ScriptRuntime.typeError("Cannot convert list of >1 element to XML");
 			}
 		}
+		if (object instanceof NativeJavaObject) {
+			Object javaObject = ((NativeJavaObject)object).unwrap();
+			if (javaObject instanceof java.io.Reader)
+				return parse((java.io.Reader)javaObject);
+		}
 		//	TODO	Technically we should fail on anything except a String, Number or Boolean
 		//			See ECMA357 10.3
 		//	Instead we just blindly cast to a String and let them convert anything.
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java,v
retrieving revision 1.7
diff -u -r1.7 XmlProcessor.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java	25 Apr 2007 22:32:17 -0000	1.7
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlProcessor.java	6 Aug 2007 16:09:27 -0000
@@ -185,13 +185,16 @@
 	}
 	
 	final Node toXml(String defaultNamespaceUri, String xml) throws org.xml.sax.SAXException {
+		String syntheticXml = "<parent xmlns=\"" + defaultNamespaceUri + "\">" + xml + "</parent>";
+		return toXml(defaultNamespaceUri,new java.io.StringReader(syntheticXml));
+	}
+	final Node toXml(String defaultNamespaceUri, java.io.Reader reader) throws org.xml.sax.SAXException {
 		//	See ECMA357 10.3.1
 		javax.xml.parsers.DocumentBuilderFactory domFactory = newDomFactory();
 		domFactory.setNamespaceAware(true);
 		domFactory.setIgnoringComments(false);
 		try {
-			String syntheticXml = "<parent xmlns=\"" + defaultNamespaceUri + "\">" + xml + "</parent>";
-			Document document = domFactory.newDocumentBuilder().parse( new org.xml.sax.InputSource(new java.io.StringReader(syntheticXml)) );
+			Document document = domFactory.newDocumentBuilder().parse( new org.xml.sax.InputSource(reader) );
 			if (ignoreProcessingInstructions) {
 				java.util.Vector v = new java.util.Vector();
 				addProcessingInstructionsTo(v, document);
@@ -223,7 +226,8 @@
 			}
 			NodeList rv = document.getDocumentElement().getChildNodes();
 			if (rv.getLength() > 1) {
-				throw ScriptRuntime.constructError("SyntaxError", "XML objects may contain at most one node.");
+				return document.getDocumentElement();
+				//throw ScriptRuntime.constructError("SyntaxError", "XML objects may contain at most one node.");
 			} else if (rv.getLength() == 0) {
 				Node node = document.createTextNode("");
 				return node;
@@ -233,7 +237,7 @@
 				return node;
 			}
 		} catch (java.io.IOException e) {
-			throw new RuntimeException("Unreachable.");
+			throw new RuntimeException(e);
 		} catch (javax.xml.parsers.ParserConfigurationException e) {
 			throw new RuntimeException(e);
 		}
Index: xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java,v
retrieving revision 1.4
diff -u -r1.4 XmlNode.java
--- xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java	7 Feb 2007 15:22:10 -0000	1.4
+++ xmlimplsrc/org/mozilla/javascript/xmlimpl/XmlNode.java	6 Aug 2007 16:09:27 -0000
@@ -101,6 +101,10 @@
 	static XmlNode createElement(XmlProcessor processor, String namespaceUri, String xml) throws org.xml.sax.SAXException {
 		return createImpl( processor.toXml(namespaceUri, xml) );
 	}
+	static XmlNode createElement(XmlProcessor processor, String namespaceUri, java.io.Reader xml) throws org.xml.sax.SAXException {
+		return createImpl( processor.toXml(namespaceUri, xml) );
+	}
+	
 	
 	static XmlNode createEmpty(XmlProcessor processor) {
 		return createText(processor, "");
Index: src/org/mozilla/javascript/FunctionNode.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/FunctionNode.java,v
retrieving revision 1.32
diff -u -r1.32 FunctionNode.java
--- src/org/mozilla/javascript/FunctionNode.java	26 Jul 2007 21:48:02 -0000	1.32
+++ src/org/mozilla/javascript/FunctionNode.java	6 Aug 2007 16:09:25 -0000
@@ -107,6 +107,14 @@
         return itsFunctionType;
     }
 
+    public void setJSDoc(String s) {
+        this.jsDoc = s;
+    }
+    public String getJSDoc() {
+        return jsDoc;
+    }
+ 
+    String jsDoc = null;
     String functionName;
     int itsFunctionType;
     boolean itsNeedsActivation;
Index: src/org/mozilla/javascript/Interpreter.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Interpreter.java,v
retrieving revision 1.330
diff -u -r1.330 Interpreter.java
--- src/org/mozilla/javascript/Interpreter.java	20 Jul 2007 12:05:29 -0000	1.330
+++ src/org/mozilla/javascript/Interpreter.java	6 Aug 2007 16:09:26 -0000
@@ -534,6 +534,7 @@
         itsData.itsFunctionType = theFunction.getFunctionType();
         itsData.itsNeedsActivation = theFunction.requiresActivation();
         itsData.itsName = theFunction.getFunctionName();
+        itsData.jsDoc = theFunction.getJSDoc();
         if (!theFunction.getIgnoreDynamicScope()) {
             if (compilerEnv.isUseDynamicScope()) {
                 itsData.useDynamicScope = true;
Index: src/org/mozilla/javascript/InterpretedFunction.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/InterpretedFunction.java,v
retrieving revision 1.56
diff -u -r1.56 InterpretedFunction.java
--- src/org/mozilla/javascript/InterpretedFunction.java	26 Jul 2007 21:48:03 -0000	1.56
+++ src/org/mozilla/javascript/InterpretedFunction.java	6 Aug 2007 16:09:25 -0000
@@ -137,6 +137,17 @@
         if (idata.itsRegExpLiterals != null) {
             functionRegExps = createRegExpWraps(cx, scope);
         }
+        if (idata.jsDoc != null) {
+            defineProperty("__jsdoc__", 
+            		Context.toString(idata.getJSDoc()), 
+            		ScriptableObject.DONTENUM);
+            defineProperty("__source__", 
+            		Context.toString(idata.getSourceName()),
+            		ScriptableObject.DONTENUM);
+            defineProperty("__lines__", 
+            		Context.javaToJS(idata.getLineNumbers(), scope),
+            		ScriptableObject.DONTENUM);
+        }
     }
 
     public String getFunctionName()
Index: src/org/mozilla/javascript/TokenStream.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/TokenStream.java,v
retrieving revision 1.68
diff -u -r1.68 TokenStream.java
--- src/org/mozilla/javascript/TokenStream.java	12 Jul 2007 15:09:18 -0000	1.68
+++ src/org/mozilla/javascript/TokenStream.java	6 Aug 2007 16:09:27 -0000
@@ -294,6 +294,8 @@
     final int getLineno() { return lineno; }
 
     final String getString() { return string; }
+    
+    final String getJSDoc() { String s = jsDoc; jsDoc = null; return s; }
 
     final double getNumber() { return number; }
 
@@ -759,6 +761,11 @@
                 }
                 if (matchChar('*')) {
                     boolean lookForSlash = false;
+                    // Marcello: JSDoc patch
+                    boolean potentialJSDoc = true;
+                    boolean inJSDoc = false;
+                    boolean readJSDoc = false;
+                    int jsDocStep = 1; // 0: space, 1: star, 2: space, 3: text
                     for (;;) {
                         c = getChar();
                         if (c == EOF_CHAR) {
@@ -766,13 +773,47 @@
                             return Token.ERROR;
                         } else if (c == '*') {
                             lookForSlash = true;
+                            if (potentialJSDoc) {
+                                inJSDoc = true;
+                                potentialJSDoc = false;
+                                stringBufferTop = 0;
+                                continue;
+                            }
                         } else if (c == '/') {
                             if (lookForSlash) {
+                                if (inJSDoc)
+                                    this.jsDoc = getStringFromBuffer();
                                 continue retry;
                             }
                         } else {
                             lookForSlash = false;
                         }
+                        potentialJSDoc = false;
+                        if (inJSDoc) {
+                            // If we hit a newline restart step
+                            if (c=='\n' && jsDocStep>=1) {
+                                jsDocStep = 0;
+                                if (readJSDoc)
+                                    addToString(c);
+                                continue;
+                            } else if (jsDocStep<3) {
+                                // Ignore asterisks if we're in step 0/1
+                                if (c=='*') {
+                                    if (jsDocStep==0)
+                                        jsDocStep=1;
+                                    if (jsDocStep==1) 
+                                        continue;
+                                // Ignore spaces in steps 0,1,2
+                                } else if (isJSSpace(c)) {
+                                    if (jsDocStep==1)
+                                        jsDocStep = 2;
+                                    continue;
+                                }   
+                            }
+                            jsDocStep = 3;
+                            addToString(c);
+                            readJSDoc = true;
+                        }
                     }
                 }
 
@@ -1381,6 +1422,9 @@
     // code.
     private String string = "";
     private double number;
+    
+    // Marcello: store jsdoc
+    private String jsDoc = null;
 
     private char[] stringBuffer = new char[128];
     private int stringBufferTop;
Index: src/org/mozilla/javascript/BaseFunction.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/BaseFunction.java,v
retrieving revision 1.63
diff -u -r1.63 BaseFunction.java
--- src/org/mozilla/javascript/BaseFunction.java	16 May 2007 12:41:00 -0000	1.63
+++ src/org/mozilla/javascript/BaseFunction.java	6 Aug 2007 16:09:25 -0000
@@ -248,6 +248,8 @@
                 } else {
                     indent = 0;
                 }
+                if (args.length>=2)
+                    flags |= ScriptRuntime.toInt32(args[1]);
             }
             return realf.decompile(indent, flags);
           }
Index: src/org/mozilla/javascript/Decompiler.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Decompiler.java,v
retrieving revision 1.25
diff -u -r1.25 Decompiler.java
--- src/org/mozilla/javascript/Decompiler.java	11 Jul 2007 16:00:00 -0000	1.25
+++ src/org/mozilla/javascript/Decompiler.java	6 Aug 2007 16:09:25 -0000
@@ -86,6 +86,17 @@
      * Flag to indicate that the decompilation generates toSource result.
      */
     public static final int TO_SOURCE_FLAG = 1 << 1;
+    
+    /**
+     * Flag to indicate that the decompilation generates a compressed result.
+     */
+    public static final int COMPRESS_FLAG = 1 << 2;
+
+    /**
+     * Flag to indicate that the decompilation generates a compressed result.
+     */
+    public static final int COMPRESS_NEWLINES_FLAG = 1 << 3;
+    
 
     /**
      * Decompilation property to specify initial ident value.
@@ -302,6 +313,10 @@
         StringBuffer result = new StringBuffer();
         boolean justFunctionBody = (0 != (flags & Decompiler.ONLY_BODY_FLAG));
         boolean toSource = (0 != (flags & Decompiler.TO_SOURCE_FLAG));
+        // Compress: features
+        boolean compress = (0 != (flags & Decompiler.COMPRESS_FLAG));
+        boolean compressnl = (0 != (flags & Decompiler.COMPRESS_NEWLINES_FLAG));
+        TokenMapper tm = new TokenMapper();
 
         // Spew tokens in source, for debugging.
         // as TYPE number char
@@ -333,6 +348,10 @@
         int braceNesting = 0;
         boolean afterFirstEOL = false;
         int i = 0;
+		int prevToken = 0;
+		boolean primeFunctionNesting = false;
+		boolean inArgsList = false;
+		boolean primeInArgsList = false;
         int topFunctionType;
         if (source.charAt(i) == Token.SCRIPT) {
             ++i;
@@ -343,7 +362,9 @@
 
         if (!toSource) {
             // add an initial newline to exactly match js.
-            result.append('\n');
+            // Compress: features
+            if (!compress)
+            	result.append('\n');
             for (int j = 0; j < indent; j++)
                 result.append(' ');
         } else {
@@ -394,7 +415,11 @@
 
             case Token.FUNCTION:
                 ++i; // skip function type
-                result.append("function ");
+				primeInArgsList = true;
+				primeFunctionNesting = true;
+                result.append("function");
+                if (Token.LP != getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case FUNCTION_END:
@@ -402,7 +427,7 @@
                 break;
 
             case Token.COMMA:
-                result.append(", ");
+                result.append(compress ? "," : ", ");
                 break;
 
             case Token.LC:
@@ -413,6 +438,7 @@
                 break;
 
             case Token.RC: {
+				tm.leaveNestingLevel(braceNesting);
                 --braceNesting;
                 /* don't print the closing RC if it closes the
                  * toplevel function and we're called from
@@ -430,18 +456,29 @@
                     case Token.WHILE:
                     case Token.ELSE:
                         indent -= indentGap;
-                        result.append(' ');
+                        if (!compress)
+	                        result.append(' ');
                         break;
                 }
                 break;
             }
             case Token.LP:
+				if (primeInArgsList) {
+					inArgsList = true;
+					primeInArgsList = false;
+				}
+				if (primeFunctionNesting) {
+					tm.enterNestingLevel(braceNesting);
+					primeFunctionNesting = false;
+				}
                 result.append('(');
                 break;
 
             case Token.RP:
+				if (inArgsList)
+					inArgsList = false;
                 result.append(')');
-                if (Token.LC == getNext(source, length, i))
+                if (!compress && Token.LC == getNext(source, length, i))
                     result.append(' ');
                 break;
 
@@ -467,7 +504,7 @@
                         newLine = false;
                     }
                 }
-                if (newLine) {
+                if (newLine && !compressnl) {
                     result.append('\n');
                 }
 
@@ -495,8 +532,9 @@
                             less = indentGap;
                     }
 
-                    for (; less < indent; less++)
-                        result.append(' ');
+					if (!compress)
+					    for (; less < indent; less++)
+					        result.append(' ');
                 }
                 break;
             }
@@ -513,15 +551,17 @@
                 break;
 
             case Token.IF:
-                result.append("if ");
+                result.append(compress ? "if" : "if ");
                 break;
 
             case Token.ELSE:
-                result.append("else ");
+                result.append(compress ? "else" : "else ");
                 break;
 
             case Token.FOR:
-                result.append("for ");
+                result.append("for");
+                if (!compress || Token.NAME == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.IN:
@@ -529,27 +569,27 @@
                 break;
 
             case Token.WITH:
-                result.append("with ");
+                result.append(compress ? "with" : "with ");
                 break;
 
             case Token.WHILE:
-                result.append("while ");
+                result.append(compress ? "while" : "while ");
                 break;
 
             case Token.DO:
-                result.append("do ");
+                result.append(compress ? "do" : "do ");
                 break;
 
             case Token.TRY:
-                result.append("try ");
+                result.append(compress ? "try" : "try ");
                 break;
 
             case Token.CATCH:
-                result.append("catch ");
+                result.append(compress ? "catch" : "catch ");
                 break;
 
             case Token.FINALLY:
-                result.append("finally ");
+                result.append(compress ? "finally" : "finally ");
                 break;
 
             case Token.THROW:
@@ -557,7 +597,7 @@
                 break;
 
             case Token.SWITCH:
-                result.append("switch ");
+                result.append(compress ? "switch" : "switch ");
                 break;
 
             case Token.BREAK:
@@ -574,6 +614,8 @@
 
             case Token.CASE:
                 result.append("case ");
+                if (!compress || Token.NAME == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.DEFAULT:
@@ -603,55 +645,55 @@
                 break;
 
             case Token.ASSIGN:
-                result.append(" = ");
+                result.append(compress ? "=" : " = ");
                 break;
 
             case Token.ASSIGN_ADD:
-                result.append(" += ");
+                result.append(compress ? "+=" : " += ");
                 break;
 
             case Token.ASSIGN_SUB:
-                result.append(" -= ");
+                result.append(compress ? "-=" : " -= ");
                 break;
 
             case Token.ASSIGN_MUL:
-                result.append(" *= ");
+                result.append(compress ? "*=" : " *= ");
                 break;
 
             case Token.ASSIGN_DIV:
-                result.append(" /= ");
+                result.append(compress ? "/=" : " /= ");
                 break;
 
             case Token.ASSIGN_MOD:
-                result.append(" %= ");
+                result.append(compress ? "%=" : " %= ");
                 break;
 
             case Token.ASSIGN_BITOR:
-                result.append(" |= ");
+                result.append(compress ? "|=" : " |= ");
                 break;
 
             case Token.ASSIGN_BITXOR:
-                result.append(" ^= ");
+                result.append(compress ? "^=" : " ^= ");
                 break;
 
             case Token.ASSIGN_BITAND:
-                result.append(" &= ");
+                result.append(compress ? "&=" : " &= ");
                 break;
 
             case Token.ASSIGN_LSH:
-                result.append(" <<= ");
+                result.append(compress ? "<<=" : " <<= ");
                 break;
 
             case Token.ASSIGN_RSH:
-                result.append(" >>= ");
+                result.append(compress ? ">>=" : " >>= ");
                 break;
 
             case Token.ASSIGN_URSH:
-                result.append(" >>>= ");
+                result.append(compress ? ">>>=" : " >>>= ");
                 break;
 
             case Token.HOOK:
-                result.append(" ? ");
+                result.append(compress ? "?" : " ? ");
                 break;
 
             case Token.OBJECTLIT:
@@ -669,59 +711,59 @@
                     result.append(':');
                 else
                     // it's the middle part of a ternary
-                    result.append(" : ");
+                    result.append(compress ? ":" : " : ");
                 break;
 
             case Token.OR:
-                result.append(" || ");
+                result.append(compress ? "||" : " || ");
                 break;
 
             case Token.AND:
-                result.append(" && ");
+                result.append(compress ? "&&" : " && ");
                 break;
 
             case Token.BITOR:
-                result.append(" | ");
+                result.append(compress ? "|" : " | ");
                 break;
 
             case Token.BITXOR:
-                result.append(" ^ ");
+                result.append(compress ? "^" : " ^ ");
                 break;
 
             case Token.BITAND:
-                result.append(" & ");
+                result.append(compress ? "&" : " & ");
                 break;
 
             case Token.SHEQ:
-                result.append(" === ");
+                result.append(compress ? "===" : " === ");
                 break;
 
             case Token.SHNE:
-                result.append(" !== ");
+                result.append(compress ? "!==" : " !== ");
                 break;
 
             case Token.EQ:
-                result.append(" == ");
+                result.append(compress ? "==" : " == ");
                 break;
 
             case Token.NE:
-                result.append(" != ");
+                result.append(compress ? "!=" : " != ");
                 break;
 
             case Token.LE:
-                result.append(" <= ");
+                result.append(compress ? "<=" : " <= ");
                 break;
 
             case Token.LT:
-                result.append(" < ");
+                result.append(compress ? "<" : " < ");
                 break;
 
             case Token.GE:
-                result.append(" >= ");
+                result.append(compress ? ">=" : " >= ");
                 break;
 
             case Token.GT:
-                result.append(" > ");
+                result.append(compress ? ">" : " > ");
                 break;
 
             case Token.INSTANCEOF:
@@ -729,15 +771,15 @@
                 break;
 
             case Token.LSH:
-                result.append(" << ");
+                result.append(compress ? "<<" : " << ");
                 break;
 
             case Token.RSH:
-                result.append(" >> ");
+                result.append(compress ? ">>" : " >> ");
                 break;
 
             case Token.URSH:
-                result.append(" >>> ");
+                result.append(compress ? ">>>" : " >>> ");
                 break;
 
             case Token.TYPEOF:
@@ -773,31 +815,39 @@
                 break;
 
             case Token.INC:
+				if (compress && Token.ADD == prevToken)
+					result.append(' ');
                 result.append("++");
+                if (compress && Token.ADD == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.DEC:
+				if (compress && Token.SUB == prevToken)
+					result.append(' ');
                 result.append("--");
+                if (compress && Token.SUB == getNext(source, length, i))
+                    result.append(' ');
                 break;
 
             case Token.ADD:
-                result.append(" + ");
+                result.append(compress ? "+" : " + ");
                 break;
 
             case Token.SUB:
-                result.append(" - ");
+                result.append(compress ? "-" : " - ");
                 break;
 
             case Token.MUL:
-                result.append(" * ");
+                result.append(compress ? "*" : " * ");
                 break;
 
             case Token.DIV:
-                result.append(" / ");
+                result.append(compress ? "/" : " / ");
                 break;
 
             case Token.MOD:
-                result.append(" % ");
+                result.append(compress ? "%" : " % ");
                 break;
 
             case Token.COLONCOLON:
@@ -826,7 +876,7 @@
 
         if (!toSource) {
             // add that trailing newline if it's an outermost function.
-            if (!justFunctionBody)
+            if (!justFunctionBody && !compressnl)
                 result.append('\n');
         } else {
             if (topFunctionType == FunctionNode.FUNCTION_EXPRESSION) {
@@ -916,3 +966,111 @@
     private static final boolean printSource = false;
 
 }
+
+
+class TokenMapper {
+	private java.util.ArrayList functionBracePositions = 
+        new java.util.ArrayList();
+	private java.util.ArrayList scopeReplacedTokens = new java.util.ArrayList();
+	private int tokenCount = 10;
+
+	// FIXME: this isn't the brightest way to accomplish this. Firstly, we need
+	// to be sure we aren't colliding with other things in the namespace!
+	private String getMappedToken(String token, boolean newMapping) {
+		String nt = null;
+        java.util.HashMap tokens = (java.util.HashMap)scopeReplacedTokens.get(scopeReplacedTokens.size()-1);
+		if (newMapping) {
+			nt = new String(Integer.toString(tokenCount++,26));
+			tokens.put(token, nt);
+			return nt;
+		}
+        String mapping = getTokenMapping(token);
+        if (mapping==null)
+            return token;
+        return mapping;
+	}
+
+	private boolean hasLocalTokenMapping(String token) {
+		if (scopeReplacedTokens.size() < 1)
+			return false;
+        java.util.HashMap tokens = (java.util.HashMap)(scopeReplacedTokens.get(scopeReplacedTokens.size()-1));
+		if (tokens.containsKey(token))
+			return true;
+		return false;
+	}
+
+	private String getTokenMapping(String token) {
+		for (int i=scopeReplacedTokens.size()-1; i>=0; i--) {
+            java.util.HashMap tokens = (java.util.HashMap)(scopeReplacedTokens.get(i));
+			if (tokens.containsKey(token))
+				return (String)tokens.get(token);
+		}
+		return null;
+	}
+
+	public int printCompressed(String 		source, 
+								int 		offset,
+								boolean 	asQuotedString,
+								StringBuffer sb, 
+								int 		prevToken, 
+								boolean 	inArgsList, 
+								int 		currentLevel) {
+		boolean newMapping = false;
+		int length = source.charAt(offset);
+		++offset;
+		if ((0x8000 & length) != 0) {
+			length = ((0x7FFF & length) << 16) | source.charAt(offset);
+			++offset;
+		}
+
+		if (sb != null) {
+			String str = source.substring(offset, offset + length);
+			String sourceStr = new String(str);
+			if (((prevToken == Token.VAR)&&(!hasLocalTokenMapping(sourceStr)))||(inArgsList))
+				newMapping = true;
+
+
+			if (((functionBracePositions.size()>0)&&(currentLevel>=(((Integer)functionBracePositions.get(functionBracePositions.size()-1)).intValue())))||(inArgsList))
+				if(prevToken != Token.DOT)
+					str = this.getMappedToken(str, newMapping);
+			if ((!inArgsList)&&(asQuotedString))
+				if((prevToken == Token.LC)||(prevToken == Token.COMMA))
+					str = sourceStr;
+
+			if(!asQuotedString){
+				sb.append(str);
+			} else {
+				sb.append('"');
+				sb.append(ScriptRuntime.escapeString(str));
+				sb.append('"');
+			}
+		}
+
+		return offset + length;
+	}
+
+	public void enterNestingLevel(int braceNesting){
+		functionBracePositions.add(new Integer(braceNesting+1));
+		scopeReplacedTokens.add(new java.util.HashMap());
+	}
+
+	public void leaveNestingLevel(int braceNesting){
+		Integer bn = new Integer(braceNesting);
+		if ((functionBracePositions.contains(bn))&&(scopeReplacedTokens.size()>0)) {
+			// remove our mappings now!
+			int scopedSize = scopeReplacedTokens.size();
+			/*
+			HashMap tokens = (HashMap)(scopeReplacedTokens.get(scopedSize-1));
+			Iterator titer = (tokens.keySet()).iterator();
+			String key = null;
+			while(titer.hasNext()){
+				key = (String)titer.next();
+				// System.out.println("removing: "+key);
+				tokenMappings.remove(key);
+			}
+			*/
+			scopeReplacedTokens.remove(scopedSize-1);
+			functionBracePositions.remove(bn);
+		}
+	}
+}
Index: src/org/mozilla/javascript/InterpreterData.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/InterpreterData.java,v
retrieving revision 1.55
diff -u -r1.55 InterpreterData.java
--- src/org/mozilla/javascript/InterpreterData.java	4 Apr 2007 20:52:10 -0000	1.55
+++ src/org/mozilla/javascript/InterpreterData.java	6 Aug 2007 16:09:26 -0000
@@ -107,6 +107,9 @@
     String encodedSource;
     int encodedSourceStart;
     int encodedSourceEnd;
+    
+    // Marcello: Added JSDoc
+    String jsDoc;
 
     int languageVersion;
 
@@ -164,6 +167,11 @@
         return itsSourceFile;
     }
 
+    public String getJSDoc()
+    {
+        return jsDoc;
+    }
+
     public boolean isGeneratedScript()
     {
         return ScriptRuntime.isGeneratedScript(itsSourceFile);
Index: src/org/mozilla/javascript/Parser.java
===================================================================
RCS file: /cvsroot/mozilla/js/rhino/src/org/mozilla/javascript/Parser.java,v
retrieving revision 1.118
diff -u -r1.118 Parser.java
--- src/org/mozilla/javascript/Parser.java	20 Jul 2007 12:06:47 -0000	1.118
+++ src/org/mozilla/javascript/Parser.java	6 Aug 2007 16:09:27 -0000
@@ -475,6 +475,9 @@
     {
         int syntheticType = functionType;
         int baseLineno = ts.getLineno();  // line number where source starts
+        
+        // Marcello: JSDoc addition
+        String jsDoc = ts.getJSDoc();
 
         int functionSourceStart = decompiler.markFunctionStart(functionType);
         String name;
@@ -609,6 +612,9 @@
         fnNode.setSourceName(sourceURI);
         fnNode.setBaseLineno(baseLineno);
         fnNode.setEndLineno(ts.getLineno());
+        // Marcello: JSDoc addition
+        fnNode.setJSDoc(jsDoc);
+         
 
         Node pn = nf.initFunction(fnNode, functionIndex, body, syntheticType);
         if (memberExprNode != null) {
Index: .project
===================================================================
RCS file: .project
diff -N .project
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ .project	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<projectDescription>
+	<name>rhinocvs</name>
+	<comment></comment>
+	<projects>
+	</projects>
+	<buildSpec>
+		<buildCommand>
+			<name>org.eclipse.jdt.core.javabuilder</name>
+			<arguments>
+			</arguments>
+		</buildCommand>
+	</buildSpec>
+	<natures>
+		<nature>org.eclipse.jdt.core.javanature</nature>
+	</natures>
+</projectDescription>
Index: .classpath
===================================================================
RCS file: .classpath
diff -N .classpath
--- /dev/null	1 Jan 1970 00:00:00 -0000
+++ .classpath	1 Jan 1970 00:00:00 -0000
@@ -0,0 +1,7 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<classpath>
+	<classpathentry kind="src" path="src"/>
+	<classpathentry kind="src" path="xmlimplsrc"/>
+	<classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
+	<classpathentry kind="output" path="bin"/>
+</classpath>

--------------------------------------------------------------------------------

RhinoServlet for the Alt Framework

 v0.02

by Marcello Bastea-Forte

--------------------------------------------------------------------------------

Website: http://marcello.cellosoft.com/projects/alt/

--------------------------------------------------------------------------------

The RhinoServlet is a Rhino-based (http://www.mozilla.org/rhino/) servlet
intended to create a platform for developing JavaScript-based web applications.

It implements a solid module system that parallel's Java's own package system,
making it easy to write clean modular JavaScript code.

The primary purpose is a basis for the the Alt Framework, but it is not limited
to this.

A jetty6-based (http://jetty.mortbay.org/jetty6/) wrapper is used to run the
HTTP server.

--------------------------------------------------------------------------------

Please Note!  RhinoServlet requires Java 1.5.0 (aka Java 5.0).

--------------------------------------------------------------------------------

Let's jump in!

Double click altlauncher.jar (or execute java -jar altlauncher.jar) to open the 
 GUI, click the "Start Server" button.

Point your web browser to http://localhost:4500/ and enjoy!

You can open up the javascript/Main.js file in your favorite text editor, any
 changes you make to the file will automatically be applied the next time you
 refresh http://localhost:4500/ in your browser.
 
That's it!

--------------------------------------------------------------------------------

The RhinoServlet is made up of several components:

	cello.alt.servlet.RhinoServlet
		This is a the main HttpServlet used to serve up HTTP pages

	cello.alt.server.HTTPServer
		This uses Jetty to run a HTTP server with RhinoServlet on the root
		It has command line options and an optional GUI.
		
	cello.alt.launcher.Launcher
		This provides an automatic Jar Classloader for the HTTPServer, it is
		used by altlauncher.jar to allow you to start the server by 
		double-clicking on OSs that support it. (java -jar altlauncher.jar)
		
  
--------------------------------------------------------------------------------
		
Scripting in RhinoServlet

Rhino provides an interesting mix of Java and JavaScript.  While you can write
pure JavaScript with RhinoServlet, the true power (and more or less a 
requirement) lies in using its ability to script Java.

Rhino makes all Java classes and functions transparent in JavaScript, and in
almost all cases, you can simply write Java code verbatim in JavaScript.  To 
access classes you can either use the Packages class (or its global "java" 
package):

  var d = new java.awt.Dimension(100,200);

Or you can make aliases:

  var Dimension = java.awt.Dimension;
  var d = new Dimension(100,200);

You can methods and access member variables just as you would in Java:

  var area = d.width * d.height;

In addition to regular syntax, Rhino adds a few convenience features for bean-
style access.  For example, if a class defines methods such as getXxx and 
setXxx, you can access them like member variables.

  var url = new java.net.URL("http://marcello.cellosoft.com/");
  var port = url.port; // same as url.getPort()
  
You can read more about scripting Java here.

  http://www.mozilla.org/rhino/ScriptingJava.html


If you are not familiar with JavaScript, a great place to start is here:
 http://developer.mozilla.org/en/docs/JavaScript
 
If you are not familiar with Java, a good place to start is here:
 http://java.sun.com/docs/books/tutorial/

You can also read about all the standard Java classes here:
  http://java.sun.com/j2se/1.5.0/docs/api/ 

--------------------------------------------------------------------------------

RhinoServlet is a standard HttpServlet, and essentially provides all the glue
for writing a JavaScript-based Servlet.

It looks for a Main.js file in the scriptpath (defaults to the javascript/ 
directory with HTTPServer) and loads that file.

After that file is loaded and compiled, it is evaluated in a request scope.

The HttpServletRequest and HttpServletResponse objects from the Java Servlet 
engine are created as JavaScript properties request and response, respectively.

Because HTTPServer uses Jetty to power its servlet engine, I recommend reading
its documentation on these two objects:

  http://jetty.mortbay.org/jetty6/servlet-api-2.5/javax/servlet/http/HttpServletRequest.html
  http://jetty.mortbay.org/jetty6/servlet-api-2.5/javax/servlet/http/HttpServletResponse.html

--------------------------------------------------------------------------------

RhinoServlet Module system

The module system is RhinoServlet's hidden power.  It provides a clean and 
effective way for handling modular JavaScript code and allows for a simple 
script compile-caching system that keeps all scripts up to date while not 
needlessly reloading scripts.

The module system acts almost identically to Java's package system.  If you have
a folder structure:

  /Main.js
  /abc/Foo.js
  /abc/Bar.js
  /abc/xyz/Sbu.js

The files can be loaded as follows:

  require("Main");
  require("abc.Foo");
  require("abc.Bar");
  require("abc.xyz.Sbu");

Similarly, you can load all of abc by writing:

  require("abc.*");

Note that this will only load Foo.js and Bar.js, Sbu.js will only be loaded if
you write "abc.xyz.*" as well.

As you can see, this is almost identical to Java's package system.  Furthermore,
like the classpath, RhinoServlet has a scriptpath.  By default you can configure
one scriptpath, but you can add more in your code with Rhino.addScript function.

Unlike Java, RhinoServlet will not automatically look for scripts.  They need to
be explicitly require'd (or at least the module require'd with .*) for them to 
be loaded.  This applies to scripts within the same module.

To enhance execution and development time, the module system will automatically 
compile and cache scripts as needed, but at the same time keeps track of file 
changes and reload scripts automatically.

This makes it easy to develop, just modify a file and reload the page, and all
the latest scripts will be used.

There is one catch due to JavaScript's nature.  In order to extend classes in
JavaScript, code looks something like this:

  // Foo.js 
  function Foo() { ... }

  // Bar.js
  require("Foo");
  function Bar() { ... }
  Bar.prototype = new Foo();

As you can see, the Bar.js file actually constructs a new Foo object to create
its prototype.  If you were then to go and modify Foo to add a function:

  // Foo.js 
  function Foo() { ... }
  Foo.prototype.sbu = function() { ... }

RhinoServlet would recognize that Foo was modified and reload it, but Bar would
still be pointing at the old Foo, the Foo that is missing the sbu() function.

This is also solved by RhinoServlet!  Using cascading dependencies, if Bar
instead called require with its second argument set to true:

  require("Foo", true);

Then RhinoServlet knows that Bar needs to be reloaded whenever Foo is reloaded.
This solves the problem without affecting the efficiency of 80% of the require'd
scripts that do not actually need the cascade reload feature.

--------------------------------------------------------------------------------

Developer notes:

The RhinoServlet implements a static class, Rhino, which contains several 
 useful properties:

  Rhino.require(scriptname[, cascadeDependency])

    Creates a dependency on the current file.  That is, if Main.js requires
    "module.Test", RhinoServlet will look for a Test.js in a module/ directory
    in the script path.  Then, every time Main.js is used, it will first check
    if module/Test.js has been updated before continuing.
    
    Scripts are evaluated in their own module scope.  So, "module.Test" would
    be evaluated in global.module.
    
    You can include an entire module by using .* (eg. require("module.*")), this
    will not include sub-modules.
    
    If cascadeDependency is true, then every time the dependency is reloaded,
    the depender will also reload, even if it has not changed.  This is 
    necessary if you intend to extend classes.  This argument is optional and
    defaults to false.
    
    This method is also global, so you can simply write require() instead of
    Rhino.require.

  Object Rhino.evaluate(scriptname[, scope])
  
    Loads and evaluates a particular script.  The scriptname follows the same
    format as require (and in fact can refer to the same Scripts).
    
    You can specify what scope the script is evaluated in (that is, what the
    "this" value will be).  This defaults to the current scope.

  (java.net.URL) Rhino.getResource(resourcepath)
  
    Gets a resource from the scriptpath.  This currently returns null. 
    Eventually it will return a URL, like Class.getResource does.
  
  Rhino.addScriptPath(pathname)
  
    Adds a script path to the list of script paths.  This can be a folder or
    a .jar/.zip file.

  Rhino.log(string)
  
    Logs a message to the console.  This method is "unofficial" and may be 
    removed in the future.

RhinoServlet implements dynamic scope.  This means allows modules to be defined
in their own scope and for separate requests to each have their own scope.

This can be illustrated as follows:


For the initial script:
  [ Top-level "global" scope ] -->  [ Module scope ] --> [ Request scope ]

For require'd modules:
  [ Top-level "global" scope ] -->  [ Module scope ]

Any variable or function you define will be defined within the bottom scope.
They will shadow any variable or function in a higher scope, but will not 
replace them.

Similarly, you can access modules by writing module.submodule, since they are
also linked from the global scope as top-level objects.

If you need to access the global scope directly, you can use the "global" 
variable, and from a request or module scope you can access the current module
through the "module" variable.  

You can read more about Rhino's dynamic scope features here:

  http://www.mozilla.org/rhino/scopes.html
  
  
--------------------------------------------------------------------------------

Library notes:
  
  This library can use MySQL connector to access MySQL:
   http://dev.mysql.com/downloads/connector/j/3.0.html
   
   Download and add mysql-connector-java-3.0.17-ga-bin.jar to the lib directory
   then use the following code to connect:
   
    java.lang.Class.forName("com.mysql.jdbc.Driver");
	var conn = java.sql.DriverManager.getConnection("jdbc:mysql://localhost/", 
													 "root", "");
													 
   Reference on using Java SQL can be found online here:
    http://java.sun.com/j2se/1.5.0/docs/api/java/sql/package-summary.html
    
   And a very in-depth tutorial can be found online here:
    http://java.sun.com/developer/onlineTraining/Database/JDBC20Intro/JDBC20.html
  
  This library potentially uses XMLBeans to use E4X in Rhino:
   http://xmlbeans.apache.org/
   
   Download and add xbean.jar to the lib directory to add E4X support.

--------------------------------------------------------------------------------


History:

Version 0.02 alpha (2006.06.22):
  - reworked module system/loader from scratch
  - added module scope for execution
  - got rid of "handle" method
  - added Rhino static class with:
    - require method
    - evaluate method
    - addScriptPath method
    - log
  - added wildcard requiring
  - other stuff I have already forgotten

Version 0.01 alpha (2006.06.19):
  - initial featureset prototype
  
  

--------------------------------------------------------------------------------

Contact:

  marcello@cellosoft.com
  
  http://marcello.cellosoft.com/
  
--------------------------------------------------------------------------------
  